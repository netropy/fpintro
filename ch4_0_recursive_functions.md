## 4.0 Recursive Functions

In the previous chapter, we've learned how to

* write a calculation as a function with parameters (_define_),
* compose a function by if-then-else or calling other functions,
* evaluate a function call with arguments (_apply_),
* plot an evaluation as a "call graph" or "call stack" diagram.

In this chapter we learn how to write calculations that carry repetition.

Before we start:

![](http://xkcdsw.com/content/img/1105.gif)

[4.1 What happens when a Function calls itself?](ch4_1_recursive_calls.md)

[4.2 Recursive Function `sum`](ch4_2_recursive_sum.md)

[4.3 Recursive Function `factorial`](ch4_3_recursive_factorial.md)

[4.4 Recursive Function `add`](ch4_4_recursive_add.md)

[4.5 Recursive Function `multiply`](ch4_5_recursive_multiply.md)

_Bonus excercise:_ Lookup the language constructs learned in this chapter in these "cheat-sheets": [Clojure](https://clojure.org/api/cheatsheet), [Clojure and other Lisp dialects](http://hyperpolyglot.org/lisp), [Scala](https://docs.scala-lang.org/cheatsheets), [Scala-to-Java](http://rea.tech/java-to-scala-cheatsheet).

---------------

[<-- previous page](ch3_3_plotting_the_evaluation_of_functions.md)

[--> next page](ch4_1_recursive_calls.md)
